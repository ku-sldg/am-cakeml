type coq_TargetT = coq_ID_Type

datatype coq_Resolute_Formula =
  R_Goal coq_TargetT coq_JSON
| R_And coq_Resolute_Formula coq_Resolute_Formula
| R_Or coq_Resolute_Formula coq_Resolute_Formula

datatype coq_Resolute_Term =
  R_Goal_T coq_TargetT coq_JSON coq_Term
| R_And_T coq_Resolute_Term coq_Resolute_Term
| R_Or_T coq_Resolute_Term coq_Resolute_Term

datatype coq_Resolute_Evidence =
  R_Goal_E coq_TargetT coq_JSON coq_Evidence
| R_And_E coq_Resolute_Evidence coq_Resolute_Evidence
| R_Or_E coq_Resolute_Evidence coq_Resolute_Evidence

datatype coq_Resolute_Judgement =
  R_Goal_J coq_TargetT coq_JSON bool
| R_And_J coq_Resolute_Judgement coq_Resolute_Judgement
| R_Or_J coq_Resolute_Judgement coq_Resolute_Judgement

datatype coq_Model =
  Build_Model ((coq_TargetT -> coq_Term))
   ((coq_TargetT -> coq_Evidence -> bool))

(** val res_to_copland :
    coq_Model -> coq_Resolute_Formula ->
    coq_Resolute_Term * (coq_Resolute_Evidence -> coq_Resolute_Judgement) **)

fun res_to_copland m r = case r of
  R_Goal tid args =>
  ((R_Goal_T tid args (let val Build_Model conc _ = m in conc tid end)),
    (fn re =>
    case re of
      R_Goal_E _ _ e =>
      R_Goal_J tid args (let val Build_Model _ spec = m in spec tid e end)
    | _ => R_Goal_J tid args False))
| R_And r1 r2 =>
  let val (t1, pol1) = res_to_copland m r1 in
  let val (t2, pol2) = res_to_copland m r2 in
  ((R_And_T t1 t2), (fn e => R_And_J (pol1 e) (pol2 e))) end end
| R_Or r1 r2 =>
  let val (t1, pol1) = res_to_copland m r1 in
  let val (t2, pol2) = res_to_copland m r2 in
  ((R_And_T t1 t2), (fn e => R_Or_J (pol1 e) (pol2 e))) end end
